/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package com.blockstream.libwally;

public class Wally {

    private static boolean loadLibrary() {
        try {
            System.loadLibrary("wallycore");
            return true;
        } catch (final UnsatisfiedLinkError e) {
            System.err.println("Native code library failed to load.\n" + e);
            return false;
        }
    }

    private static final boolean enabled = loadLibrary();
    public static boolean isEnabled() {
        return enabled;
    }

    static final class Obj {
        private final transient long ptr;
        private final int id;
        private Obj(final long ptr, final int id) { this.ptr = ptr; this.id = id; }
        private long get() { return ptr; }
        private int get_id() { return id; }
    }

  public final static native void init(long jarg1);
  public final static native int _cleanup(long jarg1);
  public final static native void secp_randomize(byte[] jarg1);
  public final static native String hex_from_bytes(byte[] jarg1);
  public final static native int hex_to_bytes(String jarg1, byte[] jarg2);
  public final static native String base58_from_bytes(byte[] jarg1, long jarg3);
  public final static native int base58_to_bytes(String jarg1, long jarg2, byte[] jarg3);
  public final static native int base58_get_length(String jarg1);
  public final static native int _is_elements_build();
  public final static native String addr_segwit_from_bytes(byte[] jarg1, String jarg3, long jarg4);
  public final static native int addr_segwit_to_bytes(String jarg1, String jarg2, long jarg3, byte[] jarg4);
  public final static native int wally_address_to_scriptpubkey(String jarg1, long jarg2, byte[] jarg3);
  public final static native String scriptpubkey_to_address(byte[] jarg1, long jarg3);
  public final static native String wif_from_bytes(byte[] jarg1, long jarg3, long jarg4);
  public final static native int wif_to_bytes(String jarg1, long jarg2, long jarg3, byte[] jarg4);
  public final static native int _wif_is_uncompressed(String jarg1);
  public final static native int wif_to_public_key(String jarg1, long jarg2, byte[] jarg3);
  public final static native String bip32_key_to_address(Object jarg1, long jarg2, long jarg3);
  public final static native String bip32_key_to_addr_segwit(Object jarg1, String jarg2, long jarg3);
  public final static native String wif_to_address(String jarg1, long jarg2, long jarg3);
  public final static native void bip32_key_free(Object jarg1);
  public final static native Object bip32_key_init(long jarg1, long jarg2, long jarg3, byte[] jarg4, byte[] jarg6, byte[] jarg8, byte[] jarg10, byte[] jarg12);
  public final static native Object bip32_key_from_seed(byte[] jarg1, long jarg3, long jarg4);
  public final static native byte[] bip32_key_serialize(Object jarg1, long jarg2, byte[] jarg3);
  public final static native Object bip32_key_unserialize(byte[] jarg1);
  public final static native Object bip32_key_from_parent(Object jarg1, long jarg2, long jarg3);
  public final static native Object bip32_key_from_parent_path(Object jarg1, int[] jarg2, long jarg4);
  public final static native String bip32_key_to_base58(Object jarg1, long jarg2);
  public final static native Object bip32_key_from_base58(String jarg1);
  public final static native int bip32_key_strip_private_key(Object jarg1);
  public final static native int bip32_key_get_fingerprint(Object jarg1, byte[] jarg2);
  public final static native byte[] bip32_key_get_chain_code(Object jarg1, byte[] jarg2);
  public final static native byte[] bip32_key_get_parent160(Object jarg1, byte[] jarg2);
  public final static native byte[] bip32_key_get_priv_key(Object jarg1, byte[] jarg2);
  public final static native byte[] bip32_key_get_hash160(Object jarg1, byte[] jarg2);
  public final static native byte[] bip32_key_get_pub_key(Object jarg1, byte[] jarg2);
  public final static native int bip32_key_get_depth(Object jarg1);
  public final static native int bip32_key_get_child_num(Object jarg1);
  public final static native int bip32_key_get_version(Object jarg1);
  public final static native byte[] bip38_raw_from_private_key(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native String bip38_from_private_key(byte[] jarg1, byte[] jarg3, long jarg5);
  public final static native byte[] bip38_raw_to_private_key(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native byte[] bip38_to_private_key(String jarg1, byte[] jarg2, long jarg4, byte[] jarg5);
  public final static native int bip38_raw_get_flags(byte[] jarg1);
  public final static native int bip38_get_flags(String jarg1);
  public final static native String bip39_get_languages();
  public final static native Object bip39_get_wordlist(String jarg1);
  public final static native String bip39_get_word(Object jarg1, long jarg2);
  public final static native String bip39_mnemonic_from_bytes(Object jarg1, byte[] jarg2);
  public final static native int bip39_mnemonic_to_bytes(Object jarg1, String jarg2, byte[] jarg3);
  public final static native void bip39_mnemonic_validate(Object jarg1, String jarg2);
  public final static native int bip39_mnemonic_to_seed(String jarg1, String jarg2, byte[] jarg3);
  public final static native void scrypt(byte[] jarg1, byte[] jarg3, long jarg5, long jarg6, long jarg7, byte[] jarg8);
  public final static native byte[] aes(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native int aes_cbc(byte[] jarg1, byte[] jarg3, byte[] jarg5, long jarg7, byte[] jarg8);
  public final static native byte[] sha256(byte[] jarg1, byte[] jarg3);
  public final static native byte[] sha256_midstate(byte[] jarg1, byte[] jarg3);
  public final static native byte[] sha256d(byte[] jarg1, byte[] jarg3);
  public final static native byte[] sha512(byte[] jarg1, byte[] jarg3);
  public final static native byte[] hash160(byte[] jarg1, byte[] jarg3);
  public final static native byte[] hmac_sha256(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native byte[] hmac_sha512(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native byte[] pbkdf2_hmac_sha256(byte[] jarg1, byte[] jarg3, long jarg5, long jarg6, byte[] jarg7);
  public final static native byte[] pbkdf2_hmac_sha512(byte[] jarg1, byte[] jarg3, long jarg5, long jarg6, byte[] jarg7);
  public final static native void ec_private_key_verify(byte[] jarg1);
  public final static native void ec_public_key_verify(byte[] jarg1);
  public final static native byte[] ec_public_key_from_private_key(byte[] jarg1, byte[] jarg3);
  public final static native byte[] ec_public_key_decompress(byte[] jarg1, byte[] jarg3);
  public final static native byte[] ec_public_key_negate(byte[] jarg1, byte[] jarg3);
  public final static native byte[] ec_sig_from_bytes(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native byte[] ec_sig_normalize(byte[] jarg1, byte[] jarg3);
  public final static native int ec_sig_to_der(byte[] jarg1, byte[] jarg3);
  public final static native byte[] ec_sig_from_der(byte[] jarg1, byte[] jarg3);
  public final static native void ec_sig_verify(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native byte[] ec_sig_to_public_key(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native int format_bitcoin_message(byte[] jarg1, long jarg3, byte[] jarg4);
  public final static native byte[] ecdh(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native int scriptpubkey_get_type(byte[] jarg1);
  public final static native int scriptpubkey_p2pkh_from_bytes(byte[] jarg1, long jarg3, byte[] jarg4);
  public final static native int scriptsig_p2pkh_from_sig(byte[] jarg1, byte[] jarg3, long jarg5, byte[] jarg6);
  public final static native Object witness_p2wpkh_from_sig(byte[] jarg1, byte[] jarg3, long jarg5, long jarg6);
  public final static native int scriptsig_p2pkh_from_der(byte[] jarg1, byte[] jarg3, byte[] jarg5);
  public final static native Object witness_p2wpkh_from_der(byte[] jarg1, byte[] jarg3, long jarg5);
  public final static native int scriptpubkey_op_return_from_bytes(byte[] jarg1, long jarg3, byte[] jarg4);
  public final static native int scriptpubkey_p2sh_from_bytes(byte[] jarg1, long jarg3, byte[] jarg4);
  public final static native int scriptpubkey_multisig_from_bytes(byte[] jarg1, long jarg3, long jarg4, byte[] jarg5);
  public final static native int scriptsig_multisig_from_bytes(byte[] jarg1, byte[] jarg3, int[] jarg5, long jarg7, byte[] jarg8);
  public final static native Object witness_multisig_from_bytes(byte[] jarg1, byte[] jarg3, int[] jarg5, long jarg7, long jarg8);
  public final static native int scriptpubkey_csv_2of2_then_1_from_bytes(byte[] jarg1, long jarg3, long jarg4, byte[] jarg5);
  public final static native int scriptpubkey_csv_2of3_then_2_from_bytes(byte[] jarg1, long jarg3, long jarg4, byte[] jarg5);
  public final static native int script_push_from_bytes(byte[] jarg1, long jarg3, byte[] jarg4);
  public final static native int witness_program_from_bytes(byte[] jarg1, long jarg3, byte[] jarg4);
  public final static native byte[] symmetric_key_from_seed(byte[] jarg1, byte[] jarg3);
  public final static native byte[] symmetric_key_from_parent(byte[] jarg1, short jarg3, byte[] jarg4, byte[] jarg6);
  public final static native Object tx_witness_stack_init(long jarg1);
  public final static native void tx_witness_stack_add(Object jarg1, byte[] jarg2);
  public final static native void tx_witness_stack_add_dummy(Object jarg1, long jarg2);
  public final static native void tx_witness_stack_set(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void tx_witness_stack_set_dummy(Object jarg1, long jarg2, long jarg3);
  public final static native void tx_witness_stack_free(Object jarg1);
  public final static native Object tx_input_init(byte[] jarg1, long jarg3, long jarg4, byte[] jarg5, Object jarg7);
  public final static native void tx_input_free(Object jarg1);
  public final static native Object tx_output_init(long jarg1, byte[] jarg2);
  public final static native void tx_output_free(Object jarg1);
  public final static native Object tx_init(long jarg1, long jarg2, long jarg3, long jarg4);
  public final static native void tx_add_input(Object jarg1, Object jarg2);
  public final static native void tx_add_raw_input(Object jarg1, byte[] jarg2, long jarg4, long jarg5, byte[] jarg6, Object jarg8, long jarg9);
  public final static native void tx_remove_input(Object jarg1, long jarg2);
  public final static native void tx_set_input_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void tx_set_input_witness(Object jarg1, long jarg2, Object jarg3);
  public final static native void tx_add_output(Object jarg1, Object jarg2);
  public final static native void tx_add_raw_output(Object jarg1, long jarg2, byte[] jarg3, long jarg5);
  public final static native void tx_remove_output(Object jarg1, long jarg2);
  public final static native int tx_get_witness_count(Object jarg1);
  public final static native void tx_free(Object jarg1);
  public final static native int tx_get_length(Object jarg1, long jarg2);
  public final static native Object tx_from_bytes(byte[] jarg1, long jarg3);
  public final static native Object tx_from_hex(String jarg1, long jarg2);
  public final static native int tx_to_bytes(Object jarg1, long jarg2, byte[] jarg3);
  public final static native String tx_to_hex(Object jarg1, long jarg2);
  public final static native int tx_get_weight(Object jarg1);
  public final static native int tx_get_vsize(Object jarg1);
  public final static native int tx_vsize_from_weight(long jarg1);
  public final static native long tx_get_total_output_satoshi(Object jarg1);
  public final static native byte[] tx_get_btc_signature_hash(Object jarg1, long jarg2, byte[] jarg3, long jarg5, long jarg6, long jarg7, byte[] jarg8);
  public final static native byte[] tx_get_signature_hash(Object jarg1, long jarg2, byte[] jarg3, byte[] jarg5, long jarg7, long jarg8, long jarg9, long jarg10, long jarg11, byte[] jarg12);
  public final static native int _tx_is_coinbase(Object jarg1);
  public final static native byte[] tx_input_get_txhash(Object jarg1, byte[] jarg2);
  public final static native int _tx_input_get_script(Object jarg1, byte[] jarg2);
  public final static native int tx_input_get_script_len(Object jarg1);
  public final static native int _tx_input_get_witness(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int tx_input_get_witness_len(Object jarg1, long jarg2);
  public final static native int tx_input_get_index(Object jarg1);
  public final static native int _tx_input_get_sequence(Object jarg1);
  public final static native void tx_input_set_txhash(Object jarg1, long jarg2, long jarg3);
  public final static native void tx_input_set_script(Object jarg1, byte[] jarg2);
  public final static native void tx_input_set_witness(Object jarg1, Object jarg2);
  public final static native void tx_input_set_index(Object jarg1, long jarg2);
  public final static native void tx_input_set_sequence(Object jarg1, long jarg2);
  public final static native int _tx_output_get_script(Object jarg1, byte[] jarg2);
  public final static native int tx_output_get_script_len(Object jarg1);
  public final static native long tx_output_get_satoshi(Object jarg1);
  public final static native void tx_output_set_script(Object jarg1, byte[] jarg2);
  public final static native void tx_output_set_satoshi(Object jarg1, long jarg2);
  public final static native int tx_get_version(Object jarg1);
  public final static native int tx_get_locktime(Object jarg1);
  public final static native int tx_get_num_inputs(Object jarg1);
  public final static native int tx_get_num_outputs(Object jarg1);
  public final static native byte[] tx_get_input_txhash(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int _tx_get_input_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int tx_get_input_script_len(Object jarg1, long jarg2);
  public final static native int _tx_get_input_witness(Object jarg1, long jarg2, long jarg3, byte[] jarg4);
  public final static native int tx_get_input_witness_len(Object jarg1, long jarg2, long jarg3);
  public final static native int tx_get_input_index(Object jarg1, long jarg2);
  public final static native int _tx_get_input_sequence(Object jarg1, long jarg2);
  public final static native void tx_set_input_index(Object jarg1, long jarg2, long jarg3);
  public final static native void tx_set_input_sequence(Object jarg1, long jarg2, long jarg3);
  public final static native void tx_set_input_txhash(Object jarg1, long jarg2, long jarg3, long jarg4);
  public final static native int _tx_get_output_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native int tx_get_output_script_len(Object jarg1, long jarg2);
  public final static native long tx_get_output_satoshi(Object jarg1, long jarg2);
  public final static native void tx_set_output_script(Object jarg1, long jarg2, byte[] jarg3);
  public final static native void tx_set_output_satoshi(Object jarg1, long jarg2, long jarg3);
  public final static int WALLY_OK = 0;
  public final static int WALLY_ERROR = -1;
  public final static int WALLY_EINVAL = -2;
  public final static int WALLY_ENOMEM = -3;
  public final static int FINGERPRINT_LEN = 4;
  public final static int WALLY_SECP_RANDOMIZE_LEN = 32;
  public final static int BASE58_FLAG_CHECKSUM = 0x1;
  public final static int BASE58_CHECKSUM_LEN = 4;
  public final static int WALLY_WIF_FLAG_COMPRESSED = 0x0;
  public final static int WALLY_WIF_FLAG_UNCOMPRESSED = 0x1;
  public final static int WALLY_CA_PREFIX_LIQUID = 0x0c;
  public final static int WALLY_CA_PREFIX_LIQUID_REGTEST = 0x04;
  public final static int WALLY_NETWORK_BITCOIN_MAINNET = 0x01;
  public final static int WALLY_NETWORK_BITCOIN_TESTNET = 0x02;
  public final static int WALLY_NETWORK_LIQUID = 0x03;
  public final static int WALLY_NETWORK_LIQUID_REGTEST = 0x04;
  public final static int WALLY_ADDRESS_TYPE_P2PKH = 0x01;
  public final static int WALLY_ADDRESS_TYPE_P2SH_P2WPKH = 0x02;
  public final static int WALLY_ADDRESS_TYPE_P2WPKH = 0x04;
  public final static int WALLY_ADDRESS_VERSION_P2PKH_MAINNET = 0x00;
  public final static int WALLY_ADDRESS_VERSION_P2PKH_TESTNET = 0x6F;
  public final static int WALLY_ADDRESS_VERSION_P2PKH_LIQUID = 0x39;
  public final static int WALLY_ADDRESS_VERSION_P2PKH_LIQUID_REGTEST = 0xEB;
  public final static int WALLY_ADDRESS_VERSION_P2SH_MAINNET = 0x05;
  public final static int WALLY_ADDRESS_VERSION_P2SH_TESTNET = 0xC4;
  public final static int WALLY_ADDRESS_VERSION_P2SH_LIQUID = 0x27;
  public final static int WALLY_ADDRESS_VERSION_P2SH_LIQUID_REGTEST = 0x4B;
  public final static int WALLY_ADDRESS_VERSION_WIF_MAINNET = 0x80;
  public final static int WALLY_ADDRESS_VERSION_WIF_TESTNET = 0xEF;
  public final static int BIP32_ENTROPY_LEN_128 = 16;
  public final static int BIP32_ENTROPY_LEN_256 = 32;
  public final static int BIP32_ENTROPY_LEN_512 = 64;
  public final static int BIP32_SERIALIZED_LEN = 78;
  public final static int BIP32_INITIAL_HARDENED_CHILD = 0x80000000;
  public final static int BIP32_FLAG_KEY_PRIVATE = 0x0;
  public final static int BIP32_FLAG_KEY_PUBLIC = 0x1;
  public final static int BIP32_FLAG_SKIP_HASH = 0x2;
  public final static int BIP32_FLAG_KEY_TWEAK_SUM = 0x4;
  public final static int BIP32_VER_MAIN_PUBLIC = 0x0488B21E;
  public final static int BIP32_VER_MAIN_PRIVATE = 0x0488ADE4;
  public final static int BIP32_VER_TEST_PUBLIC = 0x043587CF;
  public final static int BIP32_VER_TEST_PRIVATE = 0x04358394;
  public final static int LIBWALLY_CORE_BIP32_INT_H = 1;
  public final static int BIP38_KEY_MAINNET = 0;
  public final static int BIP38_KEY_TESTNET = 111;
  public final static int BIP38_KEY_COMPRESSED = 256;
  public final static int BIP38_KEY_EC_MULT = 512;
  public final static int BIP38_KEY_QUICK_CHECK = 1024;
  public final static int BIP38_KEY_RAW_MODE = 2048;
  public final static int BIP38_KEY_SWAP_ORDER = 4096;
  public final static int BIP38_SERIALIZED_LEN = 39;
  public final static int BIP39_ENTROPY_LEN_128 = 16;
  public final static int BIP39_ENTROPY_LEN_160 = 20;
  public final static int BIP39_ENTROPY_LEN_192 = 24;
  public final static int BIP39_ENTROPY_LEN_224 = 28;
  public final static int BIP39_ENTROPY_LEN_256 = 32;
  public final static int BIP39_ENTROPY_LEN_288 = 36;
  public final static int BIP39_ENTROPY_LEN_320 = 40;
  public final static int BIP39_SEED_LEN_512 = 64;
  public final static int BIP39_WORDLIST_LEN = 2048;
  public final static int AES_BLOCK_LEN = 16;
  public final static int AES_KEY_LEN_128 = 16;
  public final static int AES_KEY_LEN_192 = 24;
  public final static int AES_KEY_LEN_256 = 32;
  public final static int AES_FLAG_ENCRYPT = 1;
  public final static int AES_FLAG_DECRYPT = 2;
  public final static int SHA256_LEN = 32;
  public final static int SHA512_LEN = 64;
  public final static int HASH160_LEN = 20;
  public final static int HMAC_SHA256_LEN = 32;
  public final static int HMAC_SHA512_LEN = 64;
  public final static int PBKDF2_HMAC_SHA256_LEN = 32;
  public final static int PBKDF2_HMAC_SHA512_LEN = 64;
  public final static int EC_PRIVATE_KEY_LEN = 32;
  public final static int EC_PUBLIC_KEY_LEN = 33;
  public final static int EC_PUBLIC_KEY_UNCOMPRESSED_LEN = 65;
  public final static int EC_MESSAGE_HASH_LEN = 32;
  public final static int EC_SIGNATURE_LEN = 64;
  public final static int EC_SIGNATURE_RECOVERABLE_LEN = 65;
  public final static int EC_SIGNATURE_DER_MAX_LEN = 72;
  public final static int EC_SIGNATURE_DER_MAX_LOW_R_LEN = 71;
  public final static int EC_FLAG_ECDSA = 0x1;
  public final static int EC_FLAG_SCHNORR = 0x2;
  public final static int EC_FLAG_GRIND_R = 0x4;
  public final static int EC_FLAG_RECOVERABLE = 0x8;
  public final static int BITCOIN_MESSAGE_MAX_LEN = (64*1024-64);
  public final static int BITCOIN_MESSAGE_FLAG_HASH = 1;
  public final static int WALLY_SCRIPT_TYPE_UNKNOWN = 0x0;
  public final static int WALLY_SCRIPT_TYPE_OP_RETURN = 0x1;
  public final static int WALLY_SCRIPT_TYPE_P2PKH = 0x2;
  public final static int WALLY_SCRIPT_TYPE_P2SH = 0x4;
  public final static int WALLY_SCRIPT_TYPE_P2WPKH = 0x8;
  public final static int WALLY_SCRIPT_TYPE_P2WSH = 0x10;
  public final static int WALLY_SCRIPT_TYPE_MULTISIG = 0x20;
  public final static int WALLY_SCRIPTPUBKEY_P2PKH_LEN = 25;
  public final static int WALLY_SCRIPTPUBKEY_P2SH_LEN = 23;
  public final static int WALLY_SCRIPTPUBKEY_P2WPKH_LEN = 22;
  public final static int WALLY_SCRIPTPUBKEY_P2WSH_LEN = 34;
  public final static int WALLY_SCRIPTPUBKEY_OP_RETURN_MAX_LEN = 83;
  public final static int WALLY_MAX_OP_RETURN_LEN = 80;
  public final static int WALLY_SCRIPTSIG_P2PKH_MAX_LEN = 140;
  public final static int WALLY_WITNESSSCRIPT_MAX_LEN = 35;
  public final static int WALLY_SCRIPT_HASH160 = 0x1;
  public final static int WALLY_SCRIPT_SHA256 = 0x2;
  public final static int WALLY_SCRIPT_AS_PUSH = 0x4;
  public final static int WALLY_SCRIPT_MULTISIG_SORTED = 0x8;
  public final static int OP_0 = 0x00;
  public final static int OP_FALSE = 0x00;
  public final static int OP_PUSHDATA1 = 0x4c;
  public final static int OP_PUSHDATA2 = 0x4d;
  public final static int OP_PUSHDATA4 = 0x4e;
  public final static int OP_1NEGATE = 0x4f;
  public final static int OP_RESERVED = 0x50;
  public final static int OP_1 = 0x51;
  public final static int OP_TRUE = 0x51;
  public final static int OP_2 = 0x52;
  public final static int OP_3 = 0x53;
  public final static int OP_4 = 0x54;
  public final static int OP_5 = 0x55;
  public final static int OP_6 = 0x56;
  public final static int OP_7 = 0x57;
  public final static int OP_8 = 0x58;
  public final static int OP_9 = 0x59;
  public final static int OP_10 = 0x5a;
  public final static int OP_11 = 0x5b;
  public final static int OP_12 = 0x5c;
  public final static int OP_13 = 0x5d;
  public final static int OP_14 = 0x5e;
  public final static int OP_15 = 0x5f;
  public final static int OP_16 = 0x60;
  public final static int OP_NOP = 0x61;
  public final static int OP_VER = 0x62;
  public final static int OP_IF = 0x63;
  public final static int OP_NOTIF = 0x64;
  public final static int OP_VERIF = 0x65;
  public final static int OP_VERNOTIF = 0x66;
  public final static int OP_ELSE = 0x67;
  public final static int OP_ENDIF = 0x68;
  public final static int OP_VERIFY = 0x69;
  public final static int OP_RETURN = 0x6a;
  public final static int OP_TOALTSTACK = 0x6b;
  public final static int OP_FROMALTSTACK = 0x6c;
  public final static int OP_2DROP = 0x6d;
  public final static int OP_2DUP = 0x6e;
  public final static int OP_3DUP = 0x6f;
  public final static int OP_2OVER = 0x70;
  public final static int OP_2ROT = 0x71;
  public final static int OP_2SWAP = 0x72;
  public final static int OP_IFDUP = 0x73;
  public final static int OP_DEPTH = 0x74;
  public final static int OP_DROP = 0x75;
  public final static int OP_DUP = 0x76;
  public final static int OP_NIP = 0x77;
  public final static int OP_OVER = 0x78;
  public final static int OP_PICK = 0x79;
  public final static int OP_ROLL = 0x7a;
  public final static int OP_ROT = 0x7b;
  public final static int OP_SWAP = 0x7c;
  public final static int OP_TUCK = 0x7d;
  public final static int OP_CAT = 0x7e;
  public final static int OP_SUBSTR = 0x7f;
  public final static int OP_LEFT = 0x80;
  public final static int OP_RIGHT = 0x81;
  public final static int OP_SIZE = 0x82;
  public final static int OP_INVERT = 0x83;
  public final static int OP_AND = 0x84;
  public final static int OP_OR = 0x85;
  public final static int OP_XOR = 0x86;
  public final static int OP_EQUAL = 0x87;
  public final static int OP_EQUALVERIFY = 0x88;
  public final static int OP_RESERVED1 = 0x89;
  public final static int OP_RESERVED2 = 0x8a;
  public final static int OP_1ADD = 0x8b;
  public final static int OP_1SUB = 0x8c;
  public final static int OP_2MUL = 0x8d;
  public final static int OP_2DIV = 0x8e;
  public final static int OP_NEGATE = 0x8f;
  public final static int OP_ABS = 0x90;
  public final static int OP_NOT = 0x91;
  public final static int OP_0NOTEQUAL = 0x92;
  public final static int OP_ADD = 0x93;
  public final static int OP_SUB = 0x94;
  public final static int OP_MUL = 0x95;
  public final static int OP_DIV = 0x96;
  public final static int OP_MOD = 0x97;
  public final static int OP_LSHIFT = 0x98;
  public final static int OP_RSHIFT = 0x99;
  public final static int OP_BOOLAND = 0x9a;
  public final static int OP_BOOLOR = 0x9b;
  public final static int OP_NUMEQUAL = 0x9c;
  public final static int OP_NUMEQUALVERIFY = 0x9d;
  public final static int OP_NUMNOTEQUAL = 0x9e;
  public final static int OP_LESSTHAN = 0x9f;
  public final static int OP_GREATERTHAN = 0xa0;
  public final static int OP_LESSTHANOREQUAL = 0xa1;
  public final static int OP_GREATERTHANOREQUAL = 0xa2;
  public final static int OP_MIN = 0xa3;
  public final static int OP_MAX = 0xa4;
  public final static int OP_WITHIN = 0xa5;
  public final static int OP_RIPEMD160 = 0xa6;
  public final static int OP_SHA1 = 0xa7;
  public final static int OP_SHA256 = 0xa8;
  public final static int OP_HASH160 = 0xa9;
  public final static int OP_HASH256 = 0xaa;
  public final static int OP_CODESEPARATOR = 0xab;
  public final static int OP_CHECKSIG = 0xac;
  public final static int OP_CHECKSIGVERIFY = 0xad;
  public final static int OP_CHECKMULTISIG = 0xae;
  public final static int OP_CHECKMULTISIGVERIFY = 0xaf;
  public final static int OP_NOP1 = 0xb0;
  public final static int OP_CHECKLOCKTIMEVERIFY = 0xb1;
  public final static int OP_NOP2 = 0xb1;
  public final static int OP_CHECKSEQUENCEVERIFY = 0xb2;
  public final static int OP_NOP3 = 0xb2;
  public final static int OP_NOP4 = 0xb3;
  public final static int OP_NOP5 = 0xb4;
  public final static int OP_NOP6 = 0xb5;
  public final static int OP_NOP7 = 0xb6;
  public final static int OP_NOP8 = 0xb7;
  public final static int OP_NOP9 = 0xb8;
  public final static int OP_NOP10 = 0xb9;
  public final static int OP_INVALIDOPCODE = 0xff;
  public final static int SYMMETRIC_KEY_LEN = 32;
  public final static int WALLY_TX_SEQUENCE_FINAL = 0xffffffff;
  public final static int WALLY_TX_VERSION_1 = 1;
  public final static int WALLY_TX_VERSION_2 = 2;
  public final static int WALLY_TX_IS_ELEMENTS = 1;
  public final static int WALLY_TX_IS_ISSUANCE = 2;
  public final static int WALLY_TX_IS_PEGIN = 4;
  public final static int WALLY_TX_IS_COINBASE = 8;
  public final static int WALLY_SATOSHI_PER_BTC = 100000000;
  public final static int WALLY_BTC_MAX = 21000000;
  public final static int WALLY_TXHASH_LEN = 32;
  public final static int WALLY_TX_FLAG_USE_WITNESS = 0x1;
  public final static int WALLY_TX_FLAG_USE_ELEMENTS = 0x2;
  public final static int WALLY_TX_FLAG_BLINDED_INITIAL_ISSUANCE = 0x1;
  public final static int WALLY_TX_DUMMY_NULL = 0x1;
  public final static int WALLY_TX_DUMMY_SIG = 0x2;
  public final static int WALLY_TX_DUMMY_SIG_LOW_R = 0x4;
  public final static int WALLY_SIGHASH_ALL = 0x01;
  public final static int WALLY_SIGHASH_NONE = 0x02;
  public final static int WALLY_SIGHASH_SINGLE = 0x03;
  public final static int WALLY_SIGHASH_FORKID = 0x40;
  public final static int WALLY_SIGHASH_ANYONECANPAY = 0x80;
  public final static int WALLY_TX_ASSET_CT_VALUE_PREFIX_A = 8;
  public final static int WALLY_TX_ASSET_CT_VALUE_PREFIX_B = 9;
  public final static int WALLY_TX_ASSET_CT_ASSET_PREFIX_A = 10;
  public final static int WALLY_TX_ASSET_CT_ASSET_PREFIX_B = 11;
  public final static int WALLY_TX_ASSET_CT_NONCE_PREFIX_A = 2;
  public final static int WALLY_TX_ASSET_CT_NONCE_PREFIX_B = 3;
  public final static int WALLY_TX_ASSET_TAG_LEN = 32;
  public final static int WALLY_TX_ASSET_CT_VALUE_LEN = 33;
  public final static int WALLY_TX_ASSET_CT_VALUE_UNBLIND_LEN = 9;
  public final static int WALLY_TX_ASSET_CT_ASSET_LEN = 33;
  public final static int WALLY_TX_ASSET_CT_NONCE_LEN = 33;
  public final static int WALLY_TX_ASSET_CT_LEN = 33;
  public final static int WALLY_TX_ISSUANCE_FLAG = (1 << 31);
  public final static int WALLY_TX_PEGIN_FLAG = (1 << 30);
  public final static int WALLY_TX_INDEX_MASK = 0x3fffffff;
  public final static int LIBWALLY_CORE_TRANSACTION_INT_H = 1;
  public final static int ASSET_TAG_LEN = 32;
  public final static int BLINDING_FACTOR_LEN = 32;
  public final static int ASSET_GENERATOR_LEN = 33;
  public final static int ASSET_COMMITMENT_LEN = 33;
  public final static int ASSET_RANGEPROOF_MAX_LEN = 5134;

  // Support methods for the JNI class

  private final static byte[] trimBuffer(final byte[] buf, final int len) {
      if (len > buf.length) throw new IllegalArgumentException();
      return len == buf.length ? buf: java.util.Arrays.copyOf(buf, len);
  }

  private final static byte[] checkBuffer(final byte[] buf, final int len) {
      if (len != buf.length)
          throw new RuntimeException("Failed");
      return buf;
  }

  public final static byte[] aes(byte[] jarg1, byte[] jarg2, long jarg3) {
      return aes(jarg1, jarg2, jarg3, null);
  }

  public final static String base58check_from_bytes(byte[] bytes) {
      return base58_from_bytes(bytes, BASE58_FLAG_CHECKSUM);
  }

  private final static byte[] base58_to_bytes(String base58, long flags) {
      final byte buf[] = new byte[base58_get_length(base58)];
      final int len = base58_to_bytes(base58, flags, buf);
      return trimBuffer(buf, len);
  }

  public final static byte[] base58_to_bytes(String base58) {
      return base58_to_bytes(base58, 0);
  }

  public final static byte[] base58check_to_bytes(String base58) {
      return base58_to_bytes(base58, BASE58_FLAG_CHECKSUM);
  }

  public final static Object bip32_pub_key_init(final int version, final int depth, final int childNum,
                                         final byte[] chainCode, final byte[] pubKey) {
      return Wally.bip32_key_init(version, depth, childNum, chainCode, pubKey, null, null, null);
  }

  public final static Object bip32_priv_key_init(final int version, final int depth, final int childNum,
                                                 final byte[] chainCode, final byte[] privateKey) {
      return Wally.bip32_key_init(version, depth, childNum, chainCode, null, privateKey, null, null);
  }

  public final static byte[] bip32_key_get_chain_code(Object jarg1) {
      return bip32_key_get_chain_code(jarg1, null);
  }

  public final static byte[] bip32_key_get_parent160(Object jarg1) {
      return bip32_key_get_parent160(jarg1, null);
  }

  public final static byte[] bip32_key_get_priv_key(Object jarg1) {
      return bip32_key_get_priv_key(jarg1, null);
  }

  public final static byte[] bip32_key_get_hash160(Object jarg1) {
      return bip32_key_get_hash160(jarg1, null);
  }

  public final static byte[] bip32_key_get_pub_key(Object jarg1) {
      return bip32_key_get_pub_key(jarg1, null);
  }

  public final static byte[] bip32_key_serialize(Object jarg1, long jarg2) {
      return bip32_key_serialize(jarg1, jarg2, null);
  }

  public final static byte[] bip38_raw_from_private_key(byte[] jarg1, byte[] jarg2, long jarg3) {
      return bip38_raw_from_private_key(jarg1, jarg2, jarg3, null);
  }

  public final static byte[] bip38_to_private_key(String jarg1, byte[] jarg2, long jarg3) {
      return bip38_to_private_key(jarg1, jarg2, jarg3, null);
  }

  public final static byte[] sha256(byte[] jarg1) {
      return sha256(jarg1, null);
  }

  public final static byte[] sha256d(byte[] jarg1) {
      return sha256d(jarg1, null);
  }

  public final static byte[] sha512(byte[] jarg1) {
      return sha512(jarg1, null);
  }

  public final static byte[] hash160(byte[] jarg1) {
      return hash160(jarg1, null);
  }

  public final static byte[] hex_to_bytes(String jarg1) {
      final byte[] ret = new byte[jarg1.length() / 2];
      if (hex_to_bytes(jarg1, ret) != ret.length)
          throw new IllegalArgumentException("invalid hex string length");
      return ret;
  }

  public final static byte[] hmac_sha256(byte[] jarg1, byte[] jarg2) {
      return hmac_sha256(jarg1, jarg2, null);
  }

  public final static byte[] hmac_sha512(byte[] jarg1, byte[] jarg2) {
      return hmac_sha512(jarg1, jarg2, null);
  }

  public final static byte[] pbkdf2_hmac_sha256(byte[] jarg1, byte[] jarg2, long jarg3, long jarg4) {
      return pbkdf2_hmac_sha256(jarg1, jarg2, jarg3, jarg4, null);
  }

  public final static byte[] pbkdf2_hmac_sha512(byte[] jarg1, byte[] jarg2, long jarg3, long jarg4) {
      return pbkdf2_hmac_sha512(jarg1, jarg2, jarg3, jarg4, null);
  }

  public final static byte[] ec_public_key_from_private_key(byte[] jarg1) {
      return ec_public_key_from_private_key(jarg1, null);
  }

  public final static byte[] ec_sig_from_bytes(byte[] jarg1, byte[] jarg2, long jarg3) {
      return ec_sig_from_bytes(jarg1, jarg2, jarg3, null);
  }

  public final static byte[] ec_sig_normalize(byte[] jarg1) {
      return ec_sig_normalize(jarg1, null);
  }

  public final static byte[] ec_sig_from_der(byte[] jarg1) {
      return ec_sig_from_der(jarg1, null);
  }

  public final static byte[] ec_sig_to_public_key(byte[] jarg1, byte[] jarg2) {
      return ec_sig_to_public_key(jarg1, jarg2, null);
  }

  public final static byte[] tx_get_input_txhash(Object jarg1, long jarg2) {
        return tx_get_input_txhash(jarg1, jarg2, null);
  }

  public final static byte[] ec_sig_to_der(byte[] sig) {
      final byte[] buf = new byte[EC_SIGNATURE_DER_MAX_LEN];
      final int len = ec_sig_to_der(sig, buf);
      return trimBuffer(buf, len);
  }

  public final static byte[] format_bitcoin_message(byte[] jarg1, long jarg2) {
      int msg_len = SHA256_LEN;
      if ((jarg2 & BITCOIN_MESSAGE_FLAG_HASH) == 0)
          msg_len = 25 + jarg1.length + (jarg1.length < 253 ? 1 : 3);
      final byte[] ret = new byte[msg_len];
      if (format_bitcoin_message(jarg1, jarg2, ret) != ret.length)
          throw new IllegalArgumentException("Invalid formatted message");
      return ret;
  }

  private final static byte[] _get_push_buf(final int in_buf_len, final int extra_bytes) {
      int len = 5;
      if (in_buf_len < 76)
          len = 1;
      else if (in_buf_len < 256)
          len = 2;
      else if (in_buf_len < 65536)
          len = 3;

      return new byte[len + in_buf_len + extra_bytes];
  }

  public final static byte[] script_push_from_bytes(byte[] jarg1, long flags) {
      final byte[] ret = _get_push_buf(jarg1.length, 0);
      if (script_push_from_bytes(jarg1, flags, ret) != ret.length)
          throw new IllegalArgumentException("Error encoding push");
      return ret;
  }

  public static final byte[] scriptpubkey_p2pkh_from_bytes(byte[] bytes, long flags) {
      final byte[] buf = new byte[WALLY_SCRIPTPUBKEY_P2PKH_LEN];
      final int len = scriptpubkey_p2pkh_from_bytes(bytes, flags, buf);
      return checkBuffer(buf, len);
  }

  public static final byte[] scriptpubkey_p2sh_from_bytes(byte[] bytes, long flags) {
      final byte[] buf = new byte[WALLY_SCRIPTPUBKEY_P2SH_LEN];
      final int len = scriptpubkey_p2sh_from_bytes(bytes, flags, buf);
      return checkBuffer(buf, len);
  }

  public static final byte[] scriptpubkey_multisig_from_bytes(byte[] bytes, long threshold, long flags, int num_sigs) {
      final int required_len = 3 + num_sigs * (Wally.EC_PUBLIC_KEY_LEN + 1);
      final byte[] buf = new byte[required_len];
      final int len = scriptpubkey_multisig_from_bytes(bytes, threshold, flags, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] witness_program_from_bytes(byte[] jarg1, long flags) {
      int len = jarg1.length;
      if ((flags & WALLY_SCRIPT_HASH160) != 0)
        len = HASH160_LEN;
      else if ((flags & WALLY_SCRIPT_SHA256) != 0)
        len = SHA256_LEN;
      final byte[] ret = _get_push_buf(len, 1);
      if (witness_program_from_bytes(jarg1, flags, ret) != ret.length)
          throw new IllegalArgumentException("Error encoding witness program");
      return ret;
  }

  public static final byte[] addr_segwit_to_bytes(String jarg1, String jarg2, long jarg3) {
      final byte[] buf = new byte[32 + 2]; /* Largest v0 witness script possible */
      final int len = addr_segwit_to_bytes(jarg1, jarg2, jarg3, buf);
      return trimBuffer(buf, len);
  }

  public final static boolean wif_is_uncompressed(final String wif) {
      return _wif_is_uncompressed(wif) != 0;
  }

  public static final byte[] tx_to_bytes(final Object tx, long flags) {
      final int txlength = Wally.tx_get_length(tx, flags);
      final byte[] buf = new byte[txlength];
      final int len = Wally.tx_to_bytes(tx, flags, buf);
      return checkBuffer(buf, len);
  }

  public final static boolean tx_is_coinbase(final Object tx) {
      return _tx_is_coinbase(tx) != 0;
  }

  public final static byte[] tx_get_input_script(Object tx, long jarg2) {
      final byte[] buf = new byte[tx_get_input_script_len(tx, jarg2)];
      final int len = _tx_get_input_script(tx, jarg2, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_input_get_script(Object tx) {
      final byte[] buf = new byte[tx_input_get_script_len(tx)];
      final int len = _tx_input_get_script(tx, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_get_input_witness(Object tx, long jarg2, long jarg3) {
      final byte[] buf = new byte[tx_get_input_witness_len(tx, jarg2, jarg3)];
      final int len = _tx_get_input_witness(tx, jarg2, jarg3, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_input_get_witness(Object tx, long jarg2) {
      final byte[] buf = new byte[tx_input_get_witness_len(tx, jarg2)];
      final int len = _tx_input_get_witness(tx, jarg2, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_get_output_script(Object tx, long jarg2) {
      final byte[] buf = new byte[tx_get_output_script_len(tx, jarg2)];
      final int len = _tx_get_output_script(tx, jarg2, buf);
      return checkBuffer(buf, len);
  }

  public final static byte[] tx_output_get_script(Object tx_out) {
      final byte[] buf = new byte[tx_output_get_script_len(tx_out)];
      final int len = _tx_output_get_script(tx_out, buf);
      return checkBuffer(buf, len);
  }

  public final static long tx_get_input_sequence(final Object tx, final int index) {
    return _tx_get_input_sequence(tx, index) & 0x00000000ffffffffL;
  }

  public final static long tx_input_get_sequence(final Object tx_input) {
      return _tx_input_get_sequence(tx_input) & 0x00000000ffffffffL;
  }

  public final static boolean is_elements_build() {
      return _is_elements_build() != 0;
  }

  public final static void cleanup() {
      _cleanup(0);
  }
}
